import numpy as np

try:
    from PIL import Image
    PIL_AVAILABLE = True
except Exception:
    PIL_AVAILABLE = False


# --------------------------- small image ops (no OpenCV) ---------------------------

def _reflect_pad(a, pad_y, pad_x):
    return np.pad(a, ((pad_y, pad_y), (pad_x, pad_x)) + ((0,0),)*(a.ndim-2), mode="reflect")

def _gaussian_kernel1d(sigma, truncate=3.0):
    if sigma <= 0:
        return np.array([1.0], dtype=np.float32)
    radius = int(truncate * sigma + 0.5)
    x = np.arange(-radius, radius + 1, dtype=np.float32)
    k = np.exp(-(x**2) / (2 * sigma**2))
    k /= k.sum()
    return k

def _gaussian_blur(img, sigma):
    """Separable Gaussian blur for 2D/3D arrays (H×W or H×W×C)."""
    if sigma <= 0:
        return img.astype(np.float32, copy=False)
    k = _gaussian_kernel1d(sigma)
    out = img.astype(np.float32, copy=False)

    # blur Y
    pad = len(k)//2
    tmp = _reflect_pad(out, pad, 0)
    out = np.tensordot(k, tmp, axes=(0, 0))  # (K)·(H+2p, W[,C]) → (H, W[,C])

    # blur X
    pad = len(k)//2
    tmp = _reflect_pad(out, 0, pad)
    out = np.tensordot(tmp, k, axes=([1], [0]))  # (H, W+2p[,C])·(K) → (H, W[,C])
    return out

def _sobel_xy(img):
    """Sobel gradients for single-channel float image."""
    Kx = np.array([[-1,0,1],[-2,0,2],[-1,0,1]], dtype=np.float32)
    Ky = Kx.T
    pad = 1
    a = _reflect_pad(img, pad, pad)
    # conv (naive but small)
    H, W = img.shape
    gx = np.zeros_like(img, np.float32)
    gy = np.zeros_like(img, np.float32)
    for y in range(H):
        sl = a[y:y+3, :]
        gx[y] = (sl[:, :-2]*Kx[:,0] + sl[:,1:-1]*Kx[:,1] + sl[:,2:]*Kx[:,2]).sum(axis=0)
        gy[y] = (sl[:, :-2]*Ky[:,0] + sl[:,1:-1]*Ky[:,1] + sl[:,2:]*Ky[:,2]).sum(axis=0)
    return gx, gy

def _fbm_noise(h, w, octaves=4, persistence=0.5, seed=None):
    """Fast fBm-style noise: upsampled random layers + blending."""
    rng = np.random.RandomState(seed)
    n = np.zeros((h, w), np.float32)
    amp = 1.0
    total = 0.0
    hh, ww = max(1, h//4), max(1, w//4)
    base = rng.rand(hh, ww).astype(np.float32)
    for o in range(octaves):
        # nearest upsample (very fast), then a small Gaussian smooth
        repy = int(np.ceil(h / base.shape[0]))
        repx = int(np.ceil(w / base.shape[1]))
        layer = np.tile(base, (repy, repx))[:h, :w]
        layer = _gaussian_blur(layer, sigma=1.0 + 0.3*o)
        n += amp * layer
        total += amp
        amp *= persistence
        # next coarser base
        hh, ww = max(1, hh//2), max(1, ww//2)
        base = rng.rand(hh, ww).astype(np.float32)
    n -= n.min()
    n /= (n.max() + 1e-8)
    return n

def _bilinear_sample(img, map_y, map_x):
    """Bilinear sampler for single-channel float image."""
    H, W = img.shape[:2]
    x0 = np.floor(map_x).astype(np.int32)
    y0 = np.floor(map_y).astype(np.int32)
    x1 = x0 + 1
    y1 = y0 + 1

    x0 = np.clip(x0, 0, W-1); x1 = np.clip(x1, 0, W-1)
    y0 = np.clip(y0, 0, H-1); y1 = np.clip(y1, 0, H-1)

    Ia = img[y0, x0]
    Ib = img[y0, x1]
    Ic = img[y1, x0]
    Id = img[y1, x1]

    wa = (x1 - map_x) * (y1 - map_y)
    wb = (map_x - x0) * (y1 - map_y)
    wc = (x1 - map_x) * (map_y - y0)
    wd = (map_x - x0) * (map_y - y0)

    return (Ia*wa + Ib*wb + Ic*wc + Id*wd).astype(np.float32)

def _elastic_warp(img, alpha=6.0, sigma=6.0, seed=None):
    """Elastic deformation of single-channel float image."""
    rng = np.random.RandomState(seed)
    H, W = img.shape
    dx = (rng.rand(H, W).astype(np.float32) * 2 - 1)
    dy = (rng.rand(H, W).astype(np.float32) * 2 - 1)
    dx = _gaussian_blur(dx, sigma) * alpha
    dy = _gaussian_blur(dy, sigma) * alpha
    yy, xx = np.meshgrid(np.arange(H, dtype=np.float32), np.arange(W, dtype=np.float32), indexing="ij")
    return _bilinear_sample(img, yy + dy, xx + dx)

def _directional_blur(img, ksize=5, angle_deg=0.0, samples=None):
    """
    Average samples along a line direction (subpixel) – simple motion blur.
    img: single-channel float
    """
    if ksize <= 1:
        return img
    if samples is None:
        samples = int(max(3, ksize))
    theta = np.deg2rad(angle_deg)
    dx = np.cos(theta)
    dy = np.sin(theta)

    H, W = img.shape
    yy, xx = np.meshgrid(np.arange(H, dtype=np.float32), np.arange(W, dtype=np.float32), indexing="ij")
    acc = np.zeros_like(img, np.float32)
    # symmetric taps around 0
    offsets = np.linspace(-(ksize-1)/2, (ksize-1)/2, samples).astype(np.float32)
    for t in offsets:
        acc += _bilinear_sample(img, yy + t*dy, xx + t*dx)
    return acc / float(samples)

def _draw_line_bresenham(canvas, x0, y0, x1, y1, val):
    """Draw faint paper fiber on single-channel float canvas."""
    H, W = canvas.shape
    dx = abs(x1-x0); dy = -abs(y1-y0)
    sx = 1 if x0<x1 else -1
    sy = 1 if y0<y1 else -1
    err = dx + dy
    while True:
        if 0 <= x0 < W and 0 <= y0 < H:
            canvas[y0, x0] = max(canvas[y0, x0], val)
        if x0 == x1 and y0 == y1: break
        e2 = 2*err
        if e2 >= dy:
            err += dy; x0 += sx
        if e2 <= dx:
            err += dx; y0 += sy


# --------------------------- main: realize signature ---------------------------

def realize_signature_np(
    sig_gray,
    paper=None,
    pressure_strength=0.35,
    wobble_alpha=4.0, wobble_sigma=3.5,
    edge_roughness=0.14,
    bleed_radius=1.6, bleed_gain=0.75,
    motion_blur=5, motion_angle=10.0,
    add_grain=0.02,
    paper_strength=0.7,
    warm_tone=0.04,
    jpeg_quality=72,   # uses Pillow if available; if not, skipped
    seed=None
):
    """
    Make a clean synthetic signature (2D uint8, 0=black, 255=white) look handwritten on paper.
    Returns uint8 H×W×3 (RGB).

    Zero OpenCV. Uses only NumPy (+ optional Pillow for JPEG).
    """

    if sig_gray.ndim != 2:
        raise ValueError("sig_gray must be a 2D array (grayscale).")
    if sig_gray.dtype != np.uint8:
        sig = sig_gray.astype(np.uint8)
    else:
        sig = sig_gray.copy()

    H, W = sig.shape
    rng = np.random.RandomState(seed)

    # 1) Normalize & make "ink density" (1=ink, 0=paper)
    sigf = sig.astype(np.float32) / 255.0
    ink = 1.0 - sigf

    # 2) Pen pressure (low-freq field) * thickness proxy
    pressure = _fbm_noise(H, W, octaves=4, persistence=0.56, seed=seed)
    pressure = _gaussian_blur(pressure, 1.2)
    pressure = (pressure - 0.5) * 2.0  # [-1,1]

    # thickness proxy: blurred ink (thicker strokes have higher value)
    thick = _gaussian_blur(ink, sigma=1.2)
    thick /= (thick.max() + 1e-6)
    pressure_map = 1.0 + pressure_strength * pressure * (0.35 + 0.65 * thick)
    pressure_map = np.clip(pressure_map, 0.7, 1.3)
    ink = np.clip(ink * pressure_map, 0.0, 1.0)

    # 3) Edge roughness: perturb along gradient
    gx, gy = _sobel_xy(ink)
    mag = np.sqrt(gx*gx + gy*gy) + 1e-8
    nx, ny = gx/mag, gy/mag
    rough = _fbm_noise(H, W, octaves=3, persistence=0.6, seed=None)
    rough = (rough - 0.5) * 2.0
    ink = np.clip(ink + edge_roughness * rough * (0.25*nx + 0.25*ny), 0.0, 1.0)

    # 4) Elastic hand wobble
    ink = np.clip(_elastic_warp(ink, alpha=wobble_alpha, sigma=wobble_sigma, seed=seed), 0.0, 1.0)

    # 5) Ink bleed (capillary)
    bleed = _gaussian_blur(ink, sigma=max(0.1, float(bleed_radius)))
    ink = np.clip((1 - bleed_gain) * ink + bleed_gain * np.maximum(ink, bleed), 0.0, 1.0)

    # 6) Subtle writing motion blur
    if motion_blur and motion_blur > 1:
        ink = _directional_blur(ink, ksize=int(motion_blur), angle_deg=float(motion_angle))

    # 7) Paper texture (or adapt provided)
    if paper is None:
        tex = _fbm_noise(H, W, octaves=5, persistence=0.55, seed=seed)
        tex = _gaussian_blur(tex, 1.4)
        fibers = np.zeros((H, W), np.float32)
        n_fibers = max(2, (H*W)//80000)
        for _ in range(n_fibers):
            x0, y0 = rng.randint(0, W), rng.randint(0, H)
            length = rng.randint(max(10, W//20), max(20, W//8))
            ang = rng.uniform(0, 2*np.pi)
            x1 = int(x0 + length*np.cos(ang))
            y1 = int(y0 + length*np.sin(ang))
            _draw_line_bresenham(fibers, x0, y0, x1, y1, float(rng.uniform(0.45, 0.75)))
        fibers = _gaussian_blur(fibers, 0.8)
        paper_gray = np.clip(0.92 + 0.06*tex + 0.03*fibers, 0.0, 1.0)
        paper_rgb = np.stack([
            paper_gray + warm_tone*0.6,
            paper_gray + warm_tone*0.3,
            paper_gray
        ], axis=-1)
        paper_rgb = np.clip(paper_rgb, 0.0, 1.0)
    else:
        if paper.ndim == 2:
            p = paper.astype(np.float32)
            p = p / (255.0 if p.dtype.kind in "ui" else 1.0)
            paper_rgb = np.stack([p, p, p], axis=-1)
        elif paper.ndim == 3 and paper.shape[2] == 3:
            p = paper.astype(np.float32)
            paper_rgb = p / (255.0 if p.dtype.kind in "ui" else 1.0)
        else:
            raise ValueError("paper must be H×W or H×W×3.")
        # resize to H×W (nearest + blur to avoid ringing)
        if paper_rgb.shape[:2] != (H, W):
            # quick nearest resize with tiling + crop
            ry = int(np.ceil(H / paper_rgb.shape[0])); rx = int(np.ceil(W / paper_rgb.shape[1]))
            pr = np.tile(paper_rgb, (ry, rx, 1))[:H, :W, :]
            paper_rgb = _gaussian_blur(pr, 0.5)

    # 8) Composite (ink darkens paper)
    alpha_dark = 0.88
    T = 1.0 - alpha_dark * np.clip(ink, 0.0, 1.0)        # transmission
    img_lin = paper_rgb * T[..., None]

    # halo: tiny local darkening near strokes
    halo = _gaussian_blur(ink, 1.0)
    img_lin *= (1.0 - 0.08 * halo[..., None])

    # 9) Scanner grain & vignette
    if add_grain and add_grain > 0:
        grain = rng.randn(H, W, 3).astype(np.float32) * add_grain
        vign = _fbm_noise(H, W, octaves=3, persistence=0.6, seed=seed+1 if seed is not None else None)
        vign = _gaussian_blur(vign, 40.0)
        vign = (vign - vign.min()) / (vign.max() - vign.min() + 1e-8)
        vign = 1.0 - 0.03*(vign - 0.5)
        img_lin = np.clip(img_lin * vign[..., None] + grain, 0.0, 1.0)

    out_rgb = np.clip(img_lin, 0.0, 1.0)

    # 10) Optional JPEG-y roundtrip (Pillow) to add compression artifacts
    if PIL_AVAILABLE and jpeg_quality and (0 < jpeg_quality <= 100):
        arr = (out_rgb * 255.0 + 0.5).astype(np.uint8)
        im = Image.fromarray(arr, mode="RGB")
        from io import BytesIO
        buf = BytesIO()
        im.save(buf, format="JPEG", quality=int(jpeg_quality), subsampling=1, optimize=False)
        buf.seek(0)
        out_rgb = np.asarray(Image.open(buf).convert("RGB")).astype(np.float32) / 255.0

    # 11) Subtle low-pass (scanner optics)
    out_rgb = _gaussian_blur(out_rgb, 0.35)
    out_rgb = np.clip(out_rgb, 0.0, 1.0)

    # 12) Paper visibility strength (blend toward white if desired)
    if 0 <= paper_strength < 1.0:
        white = 1.0
        out_rgb = out_rgb * paper_strength + white * (1 - paper_strength)

    return (out_rgb * 255.0 + 0.5).astype(np.uint8)






# sig: 2D uint8, 0 = black ink, 255 = white background
realistic = realize_signature_np(
    sig,
    pressure_strength=0.4,
    wobble_alpha=5.0, wobble_sigma=3.0,
    bleed_radius=1.8, bleed_gain=0.8,
    motion_blur=5, motion_angle=12.0,
    add_grain=0.02,
    paper_strength=0.75,
    warm_tone=0.05,
    jpeg_quality=72,
    seed=123
)
