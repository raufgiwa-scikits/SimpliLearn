import numpy as np

def calculate_fpr_tpr_precision_recall_weighted(y_true, y_scores, weights=None):
    y_true = np.array(y_true)
    y_scores = np.array(y_scores)
    weights = np.ones_like(y_true) if weights is None else np.array(weights)

    # Sort by predicted scores descending
    sorted_indices = np.argsort(-y_scores)
    y_true = y_true[sorted_indices]
    y_scores = y_scores[sorted_indices]
    weights = weights[sorted_indices]

    thresholds = np.sort(np.unique(y_scores))[::-1]

    total_pos_weight = np.sum(weights[y_true == 1])
    total_neg_weight = np.sum(weights[y_true == 0])

    fpr_list = []
    tpr_list = []
    precision_list = []
    recall_list = []
    threshold_list = []

    for thresh in thresholds:
        pred = y_scores >= thresh

        TP = np.sum(weights[(pred == 1) & (y_true == 1)])
        FP = np.sum(weights[(pred == 1) & (y_true == 0)])
        FN = np.sum(weights[(pred == 0) & (y_true == 1)])
        TN = np.sum(weights[(pred == 0) & (y_true == 0)])

        TPR = TP / (TP + FN) if (TP + FN) > 0 else 0
        FPR = FP / (FP + TN) if (FP + TN) > 0 else 0
        Precision = TP / (TP + FP) if (TP + FP) > 0 else 1
        Recall = TPR

        fpr_list.append(FPR)
        tpr_list.append(TPR)
        precision_list.append(Precision)
        recall_list.append(Recall)
        threshold_list.append(thresh)

    return threshold_list, fpr_list, tpr_list, precision_list, recall_list
def compute_weighted_metrics(y_true, y_scores, weights=None):
    thresholds, fpr, tpr, precision, recall = calculate_fpr_tpr_precision_recall_weighted(
        y_true, y_scores, weights)

    # KS Statistic = max(TPR - FPR)
    ks_vals = np.abs(np.array(tpr) - np.array(fpr))
    ks_stat = np.max(ks_vals)
    best_thresh_idx = np.argmax(ks_vals)
    best_thresh = thresholds[best_thresh_idx]

    # ROC AUC using trapezoidal integration over FPR vs TPR
    roc_auc = 0.0
    for i in range(1, len(fpr)):
        roc_auc += (fpr[i] - fpr[i-1]) * (tpr[i] + tpr[i-1]) / 2.0

    # AUC PR (area under precision-recall curve)
    recall_sorted, precision_sorted = zip(*sorted(zip(recall, precision)))
    auc_pr = 0.0
    for i in range(1, len(recall_sorted)):
        auc_pr += (recall_sorted[i] - recall_sorted[i-1]) * (precision_sorted[i] + precision_sorted[i-1]) / 2.0

    return {
        "KS": ks_stat,
        "Best Threshold (Youden J)": best_thresh,
        "ROC AUC": roc_auc,
        "AUC PR": auc_pr
    }
def weighted_log_loss(y_true, y_prob, weights=None, eps=1e-15):
    y_true = np.array(y_true)
    y_prob = np.clip(np.array(y_prob), eps, 1 - eps)
    weights = np.ones_like(y_true) if weights is None else np.array(weights)
    loss = -np.average(
        y_true * np.log(y_prob) + (1 - y_true) * np.log(1 - y_prob),
        weights=weights
    )
    return loss
