def weighted_quantile(data, weights, quantile):
    """
    Compute the weighted quantile of data.

    Parameters:
        data (array-like): Data values.
        weights (array-like): Corresponding weights.
        quantile (float or array-like): Quantile(s) to compute, between 0 and 1.

    Returns:
        float or np.ndarray: The computed weighted quantile value(s).
    """
    data = np.asarray(data)
    weights = np.asarray(weights)
    quantile = np.atleast_1d(quantile)

    if len(data) != len(weights):
        raise ValueError("Data and weights must be the same length.")

    if np.any((quantile < 0) | (quantile > 1)):
        raise ValueError("Quantile values must be between 0 and 1.")

    # Sort data and corresponding weights
    sorter = np.argsort(data)
    sorted_data = data[sorter]
    sorted_weights = weights[sorter]

    # Compute cumulative weights normalized to sum to 1
    cum_weights = np.cumsum(sorted_weights)
    normalized_cum_weights = cum_weights / cum_weights[-1]

    # Compute weighted quantiles
    quantile_values = np.interp(quantile, normalized_cum_weights, sorted_data)

    # If single quantile, return scalar
    if quantile_values.size == 1:
        return quantile_values[0]
    return quantile_values
